# DSA Patterns for Coding Interviews

This repository focuses on 16 key DSA (Data Structures & Algorithms) patterns that are repeatedly used to solve a wide range of problems in coding interviews. Mastering these patterns will help you break down and solve any problem efficiently.

---

## 🧩 Pattern 1: Sliding Window

**Use When:** Dealing with subarrays, substrings, or windows in arrays/strings where size is fixed or needs to be optimized.

**Example Problems:**
- Maximum sum subarray of size ‘k’
- Longest substring with no more than K distinct characters

---

## 👣 Pattern 2: Two Pointers

**Use When:** Searching pairs or triplets in sorted arrays or when traversing arrays from both ends.

**Example Problems:**
- Pair with target sum in sorted array
- Triplet sum to zero

---

## 🐢 Pattern 3: Fast & Slow Pointers (Floyd’s Cycle)

**Use When:** Detecting cycles in linked lists or arrays.

**Example Problems:**
- Linked List cycle detection
- Happy Number

---

## 🔁 Pattern 4: Merge Intervals

**Use When:** Problems involving overlapping intervals.

**Example Problems:**
- Merge overlapping intervals
- Insert interval
- Minimum number of platforms required for trains

---

## 🔄 Pattern 5: Cyclic Sort

**Use When:** The input array has a range from 1 to N and contains missing/duplicate elements.

**Example Problems:**
- Find missing number
- Find all duplicates
- Find the first k missing positive numbers

---

## 🔃 Pattern 6: In-place Reversal of a Linked List

**Use When:** Reversing nodes in a Linked List (entire or partial), or checking palindrome structures.

**Example Problems:**
- Reverse a linked list
- Reverse nodes in k-group
- Palindrome linked list

---

## 🌳 Pattern 7: Tree Breadth First Search (BFS)

**Use When:** Level-order traversal of trees or shortest path in unweighted graphs.

**Example Problems:**
- Level order traversal
- Minimum depth of binary tree
- Connect level order siblings

---

## 🌲 Pattern 8: Depth First Search (DFS)

**Use When:** Problems involving recursion, backtracking, or exploring all paths.

**Example Problems:**
- All paths for a sum in binary tree
- Path sum
- Island count
- Maze traversal

---

## ⚖️ Pattern 9: Two Heaps

**Use When:** You need to access median or top/bottom K elements dynamically.

**Example Problems:**
- Find median from data stream
- Sliding window median
- Maximize capital

---

## 🧮 Pattern 10: Subsets (Backtracking/Bitmask)

**Use When:** Generating all combinations, permutations, or subsets.

**Example Problems:**
- Subsets
- Permutations
- Combination sum

---

## 🔍 Pattern 11: Modified Binary Search

**Use When:** The input is sorted but with some twists (rotations, infinite size, etc.)

**Example Problems:**
- Search in rotated array
- Ceiling of a number
- Next letter
- Number range

---

## 🧠 Pattern 12: Bitwise XOR

**Use When:** You are dealing with elements appearing once/twice or toggling bits.

**Example Problems:**
- Single number
- Two non-repeating elements
- Find missing number using XOR

---

## 🎯 Pattern 13: Top 'K' Elements

**Use When:** You need the K largest/smallest/frequent items from a dataset.

**Example Problems:**
- Top K frequent elements
- Kth largest number
- K closest points to origin

---

## 🔀 Pattern 14: K-way Merge

**Use When:** Merging multiple sorted arrays/lists.

**Example Problems:**
- Merge K sorted lists
- Kth smallest number in M sorted lists
- Smallest range covering elements from K lists

---

## 🎒 Pattern 15: 0/1 Knapsack (Dynamic Programming)

**Use When:** Choices with constraints, such as selecting items with maximum profit or combinations with limits.

**Example Problems:**
- 0/1 Knapsack
- Subset sum
- Partition equal subset sum

---

## 🔗 Pattern 16: Topological Sort (Graph)

**Use When:** Problems involving ordering of tasks (DAGs) or scheduling.

**Example Problems:**
- Course schedule
- Alien dictionary
- Task scheduling

